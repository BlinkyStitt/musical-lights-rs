I am not an audio engineer. This is a learning project. Suggestions welcome.

From chat gpt:

| #   | **What you do (detailed action)**                                                                                                                                                                        | **Key maths (Mathematica-style)**                                                                                    | **Units after step** |
| --- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | -------------------- |
| 0   | **Capture one analysis frame.** Read 4096 contiguous PCM samples from the ADC (or media file) and scale them so full-scale = ±1.0.                                                                       | –                                                                                                                    | FS                   |
| 1   | **Remove any DC offset** so that low-frequency energy isn’t inflated later. Compute the mean of the frame and subtract it sample-wise.                                                                   | `mu  = Mean[x];    x0[n_] := x[n] - mu`                                                                              | FS                   |
| 2   | **Apply a Hann (Hanning) window** to suppress spectral leakage that would smear narrow-band content into adjacent bins. Keep the window for the whole array.                                             | `w[n_] := 0.5 (1 - Cos[2 π n/(N - 1)]);    y[n_] := x0[n] w[n]`                                                      | FS                   |
| 3   | **Compute the 4096-point real FFT** and retain only the positive-frequency bins 0…N/2. (Bin index _k_ maps to frequency _k·fs/N_.)                                                                       | `X[k_] := Sum[y[n] Exp[-I 2 π k n/N], {n,0,N-1}]`                                                                    | FS · samples         |
| 4   | **Correct for the Hann’s 0.5 coherent gain.** Multiply every complex bin by 2 so amplitudes are back at true scale.                                                                                      | `Xc[k_] := 2 X[k]`                                                                                                   | FS · samples         |
| 5a  | **Convert each bin to mean-square power density.** Square the magnitude and divide by N² to match Parseval’s theorem.                                                                                    | `Praw[k_] := Abs[Xc[k]]^2 / N^2`                                                                                     | FS²                  |
| 5b  | **Collapse to a single-sided spectrum** (bins 1…N/2-1) by doubling power there; leave DC (k = 0) and Nyquist (k = N/2) unchanged.                                                                        | `P[k_] := If[1 <= k <= N/2 - 1, 2 Praw[k], Praw[k]]`                                                                 | FS²                  |
| 6   | **Apply IEC 61672 A-weighting per bin** to model ear sensitivity. Convert the tabulated dB curve to a linear power multiplier and scale each bin. (Skip k = 0 and k = N/2—the curve is undefined there.) | `f[k_]     := k fs/N;       A_dB[k_]  := IEC61672A[f[k]];   A_lin[k_] := 10^(A_dB[k]/10);   PA[k_] := P[k] A_lin[k]` | FS² (A-weighted)     |
| 7   | **Integrate A-weighted power into 20 critical-band buckets** (Bark/Mel or your exponential edges). Add up the bins belonging to each band.                                                               | `Eb[b_] := Sum[PA[k], {k, kLo[b], kHi[b] - 1}]`                                                                      | FS²                  |
| 8   | **Convert each band energy to RMS amplitude.** Take the square root so the value is compatible with amplitude-based level detectors.                                                                     | `RMS[b_] := Sqrt[Eb[b]]`                                                                                             | FS                   |
| 9   | **Express the RMS bands on a dBFS scale** (0 dBFS = full-scale sine RMS = 1/√2). Use 20 log₁₀ because you are now in amplitude units.                                                                    | `dBFS[b_] := 20 Log10[RMS[b]]`                                                                                       | dBFS                 |
| 10  | **Temporal-smooth the RMS values** with an exponential moving average (≈40 ms time constant) to reduce flicker but keep responsiveness.                                                                  | `RMSs[b_] := α prev + (1 - α) RMS[b]   (* α ≈ 0.85 *)`                                                               | FS                   |
| 11  | **Feed the smoothed RMS into your DAGC** (which expects amplitude RMS). The AGC adjusts gain so that average level approaches its `target_rms`.                                                          | `RMSout[b_] := DAGC[RMSs[b]]`                                                                                        | FS                   |
| 12  | **Map the AGC-regulated RMS to LED brightness.** Apply a perceptual gamma (\~0.6) and clamp to 0–1 before converting to PWM.                                                                             | `B[b_] := (RMSout[b])^0.6`                                                                                           | unitless (0–1)       |

**Key constants:** `N = 4096`; `fs = 44 100 Hz`.
All variables are frame-local; bins _k_ = 0 and _k_ = N/2 are excluded from Step 6 onward to match the A-weight definition.
